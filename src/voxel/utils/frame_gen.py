import time
import numpy as np
import logging
from jax import jit
import jax.numpy as jnp


@jit
def compute_checkered_pattern(
    z_abs: jnp.ndarray, y: jnp.ndarray, x: jnp.ndarray, initial_size: int, final_size: int
) -> jnp.ndarray:
    """
    Create a 3D JAX array with a dynamically varying checker pattern.
    :param z_abs: Precomputed Z positions.
    :type z_abs: jnp.ndarray
    :param y: Precomputed Y indices.
    :type y: jnp.ndarray
    :param x: Precomputed X indices.
    :type x: jnp.ndarray
    :param initial_size: Precomputed initial checker size.
    :type initial_size: int
    :param final_size: Precomputed final checker size.
    :type final_size: int
    :return: A 3D array with the dynamic checker pattern.
    :rtype: jnp.ndarray
    """
    nframes = z_abs.shape[0]

    # Calculate checker sizes dynamically
    t = z_abs / (nframes - 1)
    checker_size = initial_size - (initial_size - final_size) * t
    checker_size = jnp.maximum(1, jnp.round(checker_size).astype(jnp.int32))

    # Generate the checkered pattern
    checker_pattern = ((x[None, :, :] // checker_size) + (y[None, :, :] // checker_size) + z_abs) % 2

    # Scale pattern to 16-bit integers
    images = checker_pattern * 65535
    return images.astype(jnp.uint16)


def generate_checkered_batch(
    nframes: int, height_px: int, width_px: int, chunk_size: int, z_idx: int = 0
) -> np.ndarray:
    """
    Wrapper function to precompute inputs for the JIT-compiled function.
    """
    # Precompute static indices
    y, x = jnp.indices((height_px, width_px))
    start_z = z_idx * nframes
    z_abs = start_z + jnp.arange(nframes)[:, None, None]  # Add Z dimension

    # Precompute initial and final sizes for the checker pattern
    initial_size = chunk_size
    final_size = min(width_px // 4, chunk_size * 8)

    # Call the JIT-compiled function
    return compute_checkered_pattern(z_abs, y, x, initial_size, final_size)


def generate_frames(frame_count, frame_shape, batch_size_px, dtype, logger: logging.Logger | None = None):
    """Generate test frames with sequential values."""
    batch_idx = 0
    for frame_z in range(frame_count):
        start_time = time.time()
        # Fill frame with the current frame index
        frame = np.full((frame_shape.y, frame_shape.x), frame_z, dtype=dtype)
        end_time = time.time()
        time_taken = end_time - start_time
        if logger:
            logger.debug(f"Frame {frame_z} generated in {time_taken:.6f} seconds")
        # Log frame generation for debugging
        if frame_z % batch_size_px == 0:
            batch_idx += 1
        yield frame


def generate_checkered_frames(frame_count, frame_shape, dtype, logger: logging.Logger | None = None):
    """Generate test frames with checkerboard patterns."""
    min_tile_size = 4
    max_tile_size = min(frame_shape.x, frame_shape.y) // 4

    tile_sizes = np.linspace(min_tile_size, max_tile_size, num=frame_count, dtype=int)

    # Precompute meshgrid indices
    y_indices = np.arange(frame_shape.y)
    x_indices = np.arange(frame_shape.x)
    xv, yv = np.meshgrid(x_indices, y_indices)

    for frame_z in range(frame_count):
        start_time = time.time()
        tile_size = tile_sizes[frame_z]

        # Compute the checkerboard pattern directly
        checkerboard = ((xv // tile_size + yv // tile_size) % 2).astype(dtype)

        # Scale to full intensity range
        frame = checkerboard * 255

        end_time = time.time()
        time_taken = end_time - start_time
        if logger:
            logger.debug(f"Frame {frame_z} generated in {time_taken:.6f} seconds")

        yield frame


def generate_spiral_frames(frame_count, frame_shape, dtype, logger: logging.Logger | None = None):
    """Generate frames with spiral patterns."""
    min_tile_size = 2
    max_tile_size = min(frame_shape.x, frame_shape.y) // 12

    tile_sizes = np.linspace(min_tile_size, max_tile_size, num=frame_count, dtype=int)

    # Create indices centered on the frame (precomputed)
    y_indices = np.arange(frame_shape.y) - frame_shape.y // 2
    x_indices = np.arange(frame_shape.x) - frame_shape.x // 2
    xv, yv = np.meshgrid(x_indices, y_indices)

    # Precompute distance from the center
    distance = np.sqrt(xv**2 + yv**2)

    for frame_z in range(frame_count):
        start_time = time.time()
        tile_size = tile_sizes[frame_z]

        # Create expanding pattern
        pattern = ((distance // tile_size) % 2).astype(dtype)

        # Scale to full intensity range
        frame = pattern * 255

        end_time = time.time()
        time_taken = end_time - start_time
        if logger:
            logger.debug(f"Frame {frame_z} generated in {time_taken:.6f} seconds")

        yield frame
